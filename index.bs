<pre class="metadata">
Title: Loader
Group: WHATWG
H1: Loader
Shortname: loader
Repository: whatwg/loader
Inline Github Issues: true
Level: 1
Status: DREAM
ED: https://whatwg.github.io/loader
Editor: Eric Ferraiuolo, Yahoo https://yahoo.com, edf@ericf.me, https://github.com/ericf
Editor: Dave Herman, Mozilla https://mozilla.org, dherman@mozilla.com, http://calculist.org
Editor: Yehuda Katz, jQuery Foundation https://jquery.org, wycats@gmail.com, http://yehudakatz.com
Editor: Caridy Patiño, Yahoo https://yahoo.com, caridy@gmail.com, http://caridy.name
Abstract: This specification describes the behavior of loading JavaScript modules from a
Abstract: JavaScript host environment. It also provides APIs for intercepting the module
Abstract: loading process and customizing loading behavior.
Logo: https://resources.whatwg.org/logo-javascript.svg
!Version History: <a href="https://github.com/whatwg/loader/commits">https://github.com/whatwg/loader/commits</a>
!Participate: <a href="https://github.com/whatwg/loader/issues/new">File an issue</a> (<a href="https://github.com/whatwg/loader/issues?state=open">open issues</a>)

Opaque Elements: emu-alg, emu-note
</pre>

<style>
  .note + .example, .note + .note { margin-top: 1em; }

  emu-val { font-weight: bold; }
  emu-alg > ol, emu-alg > ol ol ol ol { list-style-type: decimal; }
  emu-alg > ol ol, emu-alg > ol ol ol ol ol { list-style-type: lower-alpha; }
  emu-alg > ol ol ol, emu-alg > ol ol ol ol ol ol { list-style-type: lower-roman; }
  emu-alg li { margin: 0; }
  emu-note { display: block; margin: 1em 0 1em 6em; color: #666; }
  emu-note::before { content: "Note"; text-transform: uppercase; margin-left: -6em; display: block; float: left; }
</style>
<script src="https://resources.whatwg.org/file-issue.js" async></script>

<h2 id="status" class="no-num no-toc">Status</h2>

This document is a work in progress and dreams of becoming a living standard.

<h2 id="module-loading">Module Loading</h2>

<p><i>This section is non-normative.</i></p>

<h3 id="intro">Introduction</h3>

Throughout their development, JavaScript modules have been divided into two general areas:

<ul>
<li>The <b>authoring format</b>, which defines the importing and exporting syntax, as well as the semantics for variable bindings and cycles.
<li>The <b>JavaScript Loader</b>, which provides a pipeline for on-demand, asynchronous loading of JavaScript modules.
</ul>

The authoring format was carefully designed to support pre-compilation (like Browserify) and on-demand asynchronous loading (like AMD). It defines the minimal syntax necessary to allow people to write portable modules that can work across different platforms, most notably Node.js and web browsers.

The JavaScript Loader allows host environments, like Node.js and browsers, to fetch and load modules on demand. It provides a hookable pipeline, to allow front-end packaging solutions like Browserify, WebPack and jspm to hook into the loading process.

This division provides a single format that developers can use in all JavaScript environments, and a separate loading mechanism for each environment. For example, a Node Loader would load its modules from the file system, using its own module lookup algorithm, while a Browser Loader would fetch modules and use browser-supplied packaging formats.

JavaScript itself, in ECMAScript 2015, defines the module syntax and the "linking semantics" between modules. When a module is requested, it delegates responsibility for loading the module to the host environment. The Loader defines how host environments can allow JavaScript code to configure that process.

The primary goal is to make as much of this process as possible consistent between Node and Browser environments. For example, if a JavaScript program wants to translate <code>.coffee</code> files to JavaScript on the fly, the Loader defines a "translate" hook that can be used. This allows programs to participate in the loading process, even though some details (specifically, the process of getting a particular module from its host-defined storage) will be different between environments.

<h3 id="pipeline">Loader Pipeline</h3>

<b>TODO:</b> include pipeline diagram

<h2 id="conventions">Conventions</h2>

<h3 id="well-known-symbols">Well-Known Symbols</h3>

Well-known symbols are built-in Symbol values that are explicitly referenced by algorithms of this specification. They are typically used as the keys of properties whose values serve as extension points of a specification algorithm.

Within this specification a well-known symbol is referred to by using a notation of the form @@<i>name</i>, where "<i>name</i>" is one of the values listed in table below:

<table>
  <thead>
    <tr>
      <th>Specification Name</th>
      <th>\[[Description]]</th>
      <th>Value and Purpose</th>
    </tr>
  </thead>
  <tr>
    <td>@@resolve</td>
    <td>"Reflect.Loader.resolve"</td>
    <td>A function valued property that is the resolve hook function of loader’s instances.</td>
  </tr>
  <tr>
    <td>@@fetch</td>
    <td>"Reflect.Loader.fetch"</td>
    <td>A function valued property that is the fetch hook function of loader’s instances.</td>
  </tr>
  <tr>
    <td>@@translate</td>
    <td>"Reflect.Loader.translate"</td>
    <td>A function valued property that is the translate hook function of loader’s instances.</td>
  </tr>
  <tr>
    <td>@@instantiate</td>
    <td>"Reflect.Loader.instantiate"</td>
    <td>A function valued property that is the instantiate hook function of loader’s instances.</td>
  </tr>
</table>

<h3 id="well-known-intrinsic-objects">Well-Known Intrinsic Objects</h3>

Well-known intrinsics are built-in objects that are explicitly referenced by the algorithms of this specification and which usually have Realm specific identities. Unless otherwise specified each intrinsic object actually corresponds to a set of similar objects, one per Realm.

Within this specification a reference such as %<i>name</i>% means the intrinsic object, associated with the current Realm, corresponding to the <i>name</i>. Determination of the current Realm and its intrinsics is described in ES2015, 8.3.

<h3 id="promises">Promises</h3>

This spec makes heavy use of promises, and adopts the notational conventions established in the promises guide.

<h4 id="reacting-to-promises">Reacting to Promises</h4>

<b><i>Transforming</i> p <i>with a new pass-through promise</i></b> is a shorthand for wrapping the promise to avoid exposing the original promise. It represents the following step:

<emu-alg>
1. Transforming _p_ with a fulfillment handler that, when called with argument _value_, returns _value_.
</emu-alg>

<h3 id="shorthand-phrases">Shorthand Phrases</h3>

<h4 id="reject-if-abrupt" aoid="RejectIfAbrupt">RejectIfAbrupt(x)</h4>

Algorithm steps that say

<emu-alg>
1. RejectIfAbrupt(_x_).
</emu-alg>

mean the same thing as:

<emu-alg>
1. If _x_ is an abrupt completion, then return a promise rejected with _x_.[[Value]].
1. Else if _x_ is a Completion Record, then let _x_ be _x_.[[Value]].
</emu-alg>

<h3 id="common-operations">Common Operations</h3>

<h4 id="create-object" aoid="CreateObject">CreateObject()</h4>

<emu-alg>
1. Let _obj_ be ObjectCreate(%ObjectPrototype%).
1. Return _obj_.
</emu-alg>

<h4 id="simple-define" aoid="SimpleDefine">SimpleDefine(obj, name, value)</h4>

<emu-alg>
1. Let _desc_ be a new PropertyDescriptor record {[[Value]]: _value_, [[Writable]]: *true*, [[Enumerable]]: *true*, [[Configurable]]: *true*}.
1. Return the result of calling OrdinaryDefineOwnProperty(_obj_, _name_, _desc_).
</emu-alg>

<h2 id="loader-objects">Loader Objects</h2>

<h3 id="loader-constructor">The Reflect.Loader Constructor</h3>

The Loader constructor is the initial value of the Loader property of the the Reflect object. When called as a constructor it creates and initializes a new Loader object. Reflect.Loader is not intended to be called as a function and will throw an exception when called in that manner.

The Reflect.Loader constructor is designed to be subclassable. It may be used as the value in an extends clause of a class definition. Subclass constructors that intend to inherit the specified Loader behaviour must include a super call to the Reflect.Loader constructor to create and initialize the subclass instance with the internal stage necessary to support the Reflect.Loader.prototype built-in methods.

<h4 id="new-reflect-loader">Reflect.Loader()</h4>

When Reflect.Loader is called with no arguments, the following steps are taken:

<emu-alg>
1. If NewTarget is *undefined*, then throw a *TypeError* exception.
1. Let _O_ be OrdinaryCreateFromConstructor(NewTarget, "Reflect.Loader.prototype").
1. ReturnIfAbrupt(_O_).
1. Let _registry_ to a new Registry().
1. Set _O_’s [[Registry]] internal slot to _registry_.
1. Return _O_.
</emu-alg>

<h3 id="properties-of-the-loader-constructor">Properties of the Reflect.Loader Constructor</h3>

The value of the \[[Prototype]] internal slot of the Reflect.Loader constructor is the intrinsic object %FunctionPrototype%.

Besides the internal slots and the length property (whose value is 0), the Reflect.Loader constructor has the following properties:

<h4 id="Reflect.Loader.prototype">Reflect.Loader.prototype</h4>

The value of Reflect.Loader.prototype is an ordinary object.

This property has the attributes { \[[Writable]]: false, \[[Enumerable]]: false, \[[Configurable]]: false }.

<h3 id="sec-properties-of-the-loader-prototype-object">Properties of the Reflect.Loader Prototype Object</h3>

<h4 id="Reflect.Loader.prototype.constructor">Reflect.Loader.prototype.constructor</h4>

The initial value of Reflect.Loader.prototype.constructor is Reflect.Loader.

<h4 id="reflect-loader-import">Reflect.Loader.prototype.import(name[, referrer])</h4>

The following steps are taken:

<emu-alg>
1. Let _loader_ be *this* value.
1. If Type(_loader_) is not Object, throw a *TypeError* exception.
1. Return the result of transforming Resolve(_loader_, _name_, _referrer_) with a fulfillment handler that, when called with argument _key_, runs the following steps:
  1. Let _entry_ be EnsureRegistered(_loader_, _key_).
  1. Return _entry_.load().
</emu-alg>

<h4 id="reflect-load-resolve">Reflect.Loader.prototype.resolve(name[, referrer])</h4>

The following steps are taken:

<emu-alg>
1. Let _loader_ be *this* value.
1. If Type(_loader_) is not Object, throw a *TypeError* exception.
1. Return Resolve(_loader_, _name_, _referrer_).
</emu-alg>

<h4 id="reflect-loader-load">Reflect.Loader.prototype.load(name[, referrer[, stage]])</h4>

The following steps are taken:

<emu-alg>
1. Let _loader_ be *this* value.
1. If Type(_loader_) is not Object, throw a *TypeError* exception.
1. If _stage_ is *undefined* then let _stage_ be "ready".
1. Return the result of transforming Resolve(_loader_, _name_, _referrer_) with a fulfillment handler that, when called with argument _key_, runs the following steps:
  1. Let _entry_ be EnsureRegistered(_loader_, _key_).
  1. Return _entry_.load(_stage_).
</emu-alg>

<h4 id="reflect-loader-registry">get Reflect.Loader.prototype.registry</h4>

Reflect.Loader.prototype.registry is an accessor property whose set accessor function is undefined. Its get accessor function performs the following steps:

<emu-alg>
1. Let _loader_ be *this* value.
1. Return _loader_.[[Registry]].
</emu-alg>

<h4 id="reflect-loader-@@tostringtag">Reflect.Loader.prototype [ @@toStringTag ]</h4>

The initial value of the @@toStringTag property is the String value "Object".

This property has the attributes { \[[Writable]]: false, \[[Enumerable]]: false, \[[Configurable]]: true }.

<h3 id="reflect-loader-internal-slots">Properties of Reflect.Loader Instances</h3>

Loader instances are ordinary objects that inherit properties from the *Reflect.Loader.prototype*.

Loader instances are initially created with the internal slots described in the following table:

<table>
  <thead>
    <tr>
      <th>Internal Slot</th>
      <th>Value Type (<em>non-normative</em>)</th>
      <th>Description (<em>non-normative</em>)</th>
    </tr>
  </thead>
  <tr>
    <td>\[[Realm]]</td>
    <td>Realm Record</td>
    <td>The realm this loader belongs to.</td>
  </tr>
  <tr>
    <td>\[[Registry]]</td>
    <td>An object</td>
    <td>An instance of <a href="#registry">Registry</a>.</td>
  </tr>
</table>

<h2 id="registry">Registry Objects</h2>

<h3 id="registry-constructor">The Registry Constructor</h3>

The Registry constructor is the %Registry% intrinsic object. When called as a constructor it creates and initializes a new %Registry% object. %Registry% is not intended to be called as a function and will throw an exception when called in that manner.

<h4 id="new-registry" aoid="Registry">Registry()</h4>

When Registry is called with no arguments, the following steps are taken:

<emu-alg>
1. If NewTarget is *undefined*, then throw a *TypeError* exception.
1. Let _O_ be OrdinaryCreateFromConstructor(NewTarget, "%RegistryPrototype%", «[[Entries]]» ).
1. ReturnIfAbrupt(_O_).
1. Set _O_’s [[Entries]] internal slot to a new empty List.
1. Return _O_.
</emu-alg>

<h3 id="properties-of-the-registry-constructor">Properties of the Registry Constructor</h3>

The value of the \[[Prototype]] internal slot of the Registry constructor is the intrinsic object %FunctionPrototype%.

Besides the internal slots and the length property (whose value is 0), the Registry constructor has the following properties:

<h4 id="registry-prototype">Registry.prototype</h4>

The value of Registry.prototype is %RegistryPrototype%.

This property has the attributes { \[[Writable]]: false, \[[Enumerable]]: false, \[[Configurable]]: false }.

<h3 id="registry-prototype-object">Properties of the Registry Prototype Object</h3>

<h4 id="registry-prototype-constructor">Registry.prototype.constructor</h4>

The initial value of Registry.prototype.constructor is %Registry%.

<h4 id="registry-prototype-@@iterator">Registry.prototype[ @@iterator ]()</h4>

When the @@iterator method is called it returns an Iterator object (ES2015 25.1.1.2) that iterates over the registry entries of the \[[Entries]] internal slot, returning each entry as a key value pair. The following steps are taken:

<emu-alg>
1. Let _registry_ be *this* value.
1. If Type(_registry_) is not Object, throw a *TypeError* exception.
1. If _registry_ does not have a [[Entries]] internal slot, throw a *TypeError* exception.
1. Let _entries_ be a new List.
1. For each _pair_ in _registry_.[[Entries]], do:
  1. Let _key_ be _pair_.[[Key]].
  1. Let _value_ be _pair_.[[Value]].
  1. Append { [[Key]]: _key_, [[Value]]: _value_ } to _entries_.
1. Return CreateListIterator(_entries_).
</emu-alg>

The value of the name property of this function is "[Symbol.iterator]".

<h4 id="registry-prototype-get">Registry.prototype.get(key)</h4>

The following steps are taken:

<emu-alg>
1. Let _registry_ be *this* value.
1. If Type(_registry_) is not Object, throw a *TypeError* exception.
1. If _registry_ does not have a [[Entries]] internal slot, throw a *TypeError* exception.
1. Let _entries_ be _registry_.[[Entries]].
1. Let _pair_ be the entry in _entries_ such that _pair_.[[Key]] is equal to _key_.
1. If _pair_ exists, then return _pair_.[[Value]]. Otherwise return *undefined*.
</emu-alg>

<h4 id="registry-prototype-set">Registry.prototype.set(key, entry)</h4>

The following steps are taken:

<emu-alg>
1. Let _registry_ be *this* value.
1. If Type(_registry_) is not Object, throw a *TypeError* exception.
1. If _registry_ does not have a [[Entries]] internal slot, throw a *TypeError* exception.
1. Assert: _entry_ is an initialized RegistryEntry instance.
1. Let _entries_ be _registry_.[[Entries]].
1. Let _pair_ be the entry in _entries_ such that _pair_.[[Key]] is equal to _key_.
1. If _pair_ exists, then throw a new *TypeError*.
1. Append { [[Key]]: _key_, [[Value]]: _entry_ } to _entries_.
1. Return _registry_.
</emu-alg>

<h4 id="registry-prototype-has">Registry.prototype.has(key)</h4>

The following steps are taken:

<emu-alg>
1. Let _registry_ be *this* value.
1. If Type(_registry_) is not Object, throw a *TypeError* exception.
1. If _registry_ does not have a [[Entries]] internal slot, throw a *TypeError* exception.
1. Let _entries_ be _registry_.[[Entries]].
1. Let _pair_ be the entry in _entries_ such that _pair_.[[Key]] is equal to _key_.
1. If _pair_ exist, return *true*. Otherwise return *false*.
</emu-alg>

<h4 id="registry-prototype-delete">Registry.prototype.delete(key)</h4>

The following steps are taken:

<emu-alg>
1. Let _registry_ be *this* value.
1. If Type(_registry_) is not Object, throw a *TypeError* exception.
1. If _registry_ does not have a [[Entries]] internal slot, throw a *TypeError* exception.
1. Let _entries_ be _registry_.[[Entries]].
1. Let _pair_ be the entry in _entries_ such that _pair_.[[Key]] is equal to _key_.
1. If _pair_ does not exist, then throw a new *TypeError*.
1. Remove _pair_ from _entries_.
1. Return *true*.
</emu-alg>

<h3 id="registry-internal-slots">Properties of Registry Instances</h3>

Registry instances are ordinary objects that inherit properties from the %RegistryPrototype%.

Registry instances are initially created with the internal slots described in the following table:

<table>
  <thead>
    <tr>
      <th>Internal Slot</th>
      <th>Value Type (<em>non-normative</em>)</th>
      <th>Description (<em>non-normative</em>)</th>
    </tr>
  </thead>
  <tr>
    <td>\[[Entries]]</td>
    <td>List of pairs of String and <a href="#registry-entry">registry entry</a>.</td>
    <td>The registry of installed modules.</td>
  </tr>
</table>

<h2 id="registry-entry">Registry Entry Objects</h2>

<h3 id="registry-entry-abstract-operations">Abstract Operations for Registry Entry Objects</h3>

<h4 id="registry-entry-GetCurrentStage" aoid="GetCurrentStage">GetCurrentStage(entry)</h4>

The abstract operation GetCurrentStage with argument entry performs the following steps:

<emu-alg>
1. If Type(_entry_) is not Object, throw a *TypeError* exception.
1. If _entry_ does not have a [[Pipeline]] internal slot, throw a *TypeError* exception.
1. Let _stages_ be _entry_.[[Pipeline]].
1. Return the first element of _stages_.
</emu-alg>

<h4 id="registry-entry-GetStage" aoid="GetStage">GetStage(entry, stage)</h4>

The abstract operation GetStage with arguments entry and stage performs the following steps:

<emu-alg>
1. If Type(_entry_) is not Object, throw a *TypeError* exception.
1. If _entry_ does not have a [[Pipeline]] internal slot, throw a *TypeError* exception.
1. Let _stages_ be _entry_.[[Pipeline]].
1. For each element _entry_ of _stages_, do
  1. If _entry_.[[Stage]] is equal to _stage_, then
    1. Return _entry_.
1. Return *undefined*.
</emu-alg>

<h4 id="registry-entry-UpgradeToStage" aoid="UpgradeToStage">UpgradeToStage(entry, stage)</h4>

<emu-alg>
1. If Type(_entry_) is not Object, throw a *TypeError* exception.
1. If _entry_ does not have a [[Pipeline]] internal slot, throw a *TypeError* exception.
1. Let _pipeline_ be _entry_.[[Pipeline]].
1. Let _stageEntry_ be GetStage(_entry_, _stage_).
1. If _stageEntry_ is not *undefined*, then
  1. Repeat while the first element of _pipeline_ is not equal to _stageEntry_
    1. Remove first element from _pipeline_.
</emu-alg>

<emu-note>
  The internal slot [[Pipeline]] of an entry can never be empty.
</emu-note>

<emu-note>
  Alternative, this algo can be implemented using functional programming techinques or a reverse cycle to avoid walking the entries twice.
</emu-note>

An <dfn id="stage-entry">stage</dfn> is a record with the following fields:

<table>
  <thead>
    <tr>
      <th>Internal Slot</th>
      <th>Value Type (<em>non-normative</em>)</th>
      <th>Description (<em>non-normative</em>)</th>
    </tr>
  </thead>
  <tr>
    <td>\[[Stage]]</td>
    <td><code>"fetch"</code>, <code>"translate"</code>, <code>"instantiate"</code>, <code>"satisfy"</code>, <code>"link"</code>, <code>"ready"</code></td>
    <td>A constant value to indicating which phase the entry is at.</td>
  </tr>
  <tr>
    <td>\[[Result]]</td>
    <td>Promise or <code>undefined</code></td>
    <td>A promise for the stage entry.</td>
  </tr>
</table>

Each \[[Stage]] value indicates the currently pending operation. If the \[[Result]] field is *undefined*, the operation has not been initiated; if the \[[Result]] field is a promise, the operation has been initiated but not completed. Once a stage completes, its Stage Entry is removed from the pipeline. The following table describes the intended purpose of each stage of the pipeline:

<table>
  <thead>
    <tr>
      <th>Value</th>
      <th>Description (<em>non-normative</em>)</th>
  </thead>
  <tr>
    <td><code>"fetch"</code></td>
    <td>fetching the requested module (e.g. from a filesystem or network)</td>
  </tr>
  <tr>
    <td><code>"translate"</code></td>
    <td>translating the fetched source (as via a preprocessor or compiler)</td>
  </tr>
  <tr>
    <td><code>"instantiate"</code></td>
    <td>instantiating the translated source as a Module Record</td>
  </tr>
  <tr>
    <td><code>"satisfy"</code></td>
    <td>satisfying the module's dependency graph by instantiating all of its (direct or indirect) dependencies</td>
  </tr>
  <tr>
    <td><code>"link"</code></td>
    <td>linking all imports and exports of the module's dependency graph</td>
  </tr>
  <tr>
    <td><code>"ready"</code></td>
    <td>fully loaded and initialized</td>
  </tr>
</table>

<h3 id="registry-entry-constructor">The Registry Entry Constructor</h3>

The Registry Entry constructor is the %RegistryEntry% intrinsic object. When called as a constructor it creates and initializes a new %RegistryEntry% object. %RegistryEntry% is not intended to be called as a function and will throw an exception when called in that manner.

<h4 id="new-registry-entry" aoid="RegistryEntry">RegistryEntry(loader)</h4>

When Registry is called with argument <i>loader</i>, the following steps are taken:

<emu-alg>
1. If NewTarget is *undefined*, then throw a *TypeError* exception.
1. If Type(_loader_) is not Object, throw a *TypeError* exception.
1. Let _O_ be OrdinaryCreateFromConstructor(NewTarget, "%RegistryPrototype%", «[[Loader]], [[Pipeline]], [[Module]], [[Metadata]], [[Dependencies]], [[Error]]» ).
1. ReturnIfAbrupt(_O_).
1. Let _pipeline_ be a new List.
1. Add new stage entry record { [[Stage]]: "fetch", [[Result]]: *undefined* } as a new element of the list _pipeline_.
1. Add new stage entry record { [[Stage]]: "translate", [[Result]]: *undefined* } as a new element of the list _pipeline_.
1. Add new stage entry record { [[Stage]]: "instantiate", [[Result]]: *undefined* } as a new element of the list _pipeline_.
1. Add new stage entry record { [[Stage]]: "satisfy", [[Result]]: *undefined* } as a new element of the list _pipeline_.
1. Add new stage entry record { [[Stage]]: "link", [[Result]]: *undefined* } as a new element of the list _pipeline_.
1. Add new stage entry record { [[Stage]]: "ready", [[Result]]: *undefined* } as a new element of the list _pipeline_.
1. Set _O_’s [[Loader]] internal slot to _loader_.
1. Set _O_’s [[Pipeline]] internal slot to _pipeline_.
1. Set _O_’s [[Module]] internal slot to *undefined*.
1. Set _O_’s [[Metadata]] internal slot to *undefined*.
1. Set _O_’s [[Dependencies]] internal slot to *undefined*.
1. Set _O_’s [[Error]] internal slot to *nothing*.
1. Return _O_.
</emu-alg>

<emu-note>
  A registry entry is associated to a loader instance at the time of its creation, the [[Loader]] backpointer reflects that.
</emu-note>

<emu-note>
  A registry entry can be set into multiple Register instances.
</emu-note>

<h3 id="properties-of-the-registry-entry-constructor">Properties of the Registry Entry Constructor</h3>

The value of the \[[Prototype]] internal slot of the Registry constructor is the intrinsic object %FunctionPrototype%.

Besides the internal slots and the length property (whose value is 0), the Registry constructor has the following properties:

<h4 id="registry-entry-prototype">RegistryEntry.prototype</h4>

The value of RegistryEntry.prototype is %RegistryEntryPrototype%.

This property has the attributes { \[[Writable]]: false, \[[Enumerable]]: false, \[[Configurable]]: false }.

<h3 id="registry-entry-prototype-object">Properties of the Registry Entry Prototype Object</h3>

<h4 id="registry-entry-prototype-constructor">RegistryEntry.prototype.constructor</h4>

The initial value of RegistryEntry.prototype.constructor is %Registry%.

<h4 id="registry-entry-stage">get RegistryEntry.prototype.stage</h4>

RegistryEntry.prototype.stage is an accessor property whose set accessor function is undefined. Its get accessor function performs the following steps:

<emu-alg>
1. Let _entry_ be *this* value.
1. If Type(_entry_) is not Object, throw a *TypeError* exception.
1. Let _stageEntry_ be GetCurrentStage(_entry_).
1. Return _stageEntry_.[[Stage]].
</emu-alg>

<h4 id="registry-entry-module">get RegistryEntry.prototype.module</h4>

RegistryEntry.prototype.module is an accessor property whose set accessor function is undefined. Its get accessor function performs the following steps:

<emu-alg>
1. Let _entry_ be *this* value.
1. If Type(_entry_) is not Object, throw a *TypeError* exception.
1. If _entry_ does not have a [[Module]] internal slot, throw a *TypeError* exception.
1. Return _entry_.[[Module]].
</emu-alg>

<h4 id="registry-entry-prototype-load">RegistryEntry.prototype.load(stage)</h4>

The following steps are taken:

<emu-alg>
1. Let _entry_ be *this* value.
1. If _entry_ is not an initialized RegistryEntry instance, then return a promise rejected with a new *TypeError* exception.
1. If _stage_ is "fetch", then:
  1. Return the result of transforming RequestFetch(_entry_) with a new pass-through promise.
1. If _stage_ is "translate", then:
  1. Return the result of transforming RequestTranslate(_entry_) with a new pass-through promise.
1. If _stage_ is "instantiate", then:
  1. Return the result of transforming RequestInstantiate(_entry_) with a fulfillment handler that, when called with argument _entry_, runs the following steps:
    1. If _entry_.[[Module]] is a Function object, return _entry_.[[Module]].
    1. Return *undefined*.
1. If _stage_ is "satisfy", then:
  1. Return the result of transforming RequestSatisfy(_entry_) with a fulfillment handler that, when called with argument _entry_, runs the following steps:
    1. If _entry_.[[Module]] is a Function object, return _entry_.[[Module]].
    1. Return *undefined*.
1. If _stage_ is "link", then:
  1. Return the result of transforming RequestLink(_entry_) with a fulfillment handler that returns *undefined*.
1. If _stage_ is "ready" or *undefined*, then:
  1. Return the result of transforming RequestReady(_entry_) with a fulfillment handler that, when called with argument _entry_, runs the following steps:
    1. Return GetModuleNamespace(_entry_.[[Module]]).
1. Return a promise rejected with a new *RangeError* exception.
</emu-alg>

<h4 id="registry-entry-prototype-result">RegistryEntry.prototype.result(stage)</h4>

The following steps are taken:

<emu-alg>
1. Let _entry_ be *this* value.
1. If Type(_entry_) is not Object, return a promise rejected with a new *TypeError* exception.
1. If _stage_ is not "fetch", "translate", "instantiate", "satisfy", "link" or "ready", return a promise rejected with a new *RangeError* exception.
1. Let _stageEntry_ be GetStage(_entry_, _stage_).
1. If _stageEntry_ is an abrupt completion, return a promise rejected with a new *TypeError* exception.
1. If _stageEntry_ is *undefined*, return a promise resolved with *undefined*.
1. If _stageEntry_.[[Result]] is *undefined*, return a promise resolved with *undefined*.
1. Return the result of transforming _stageEntry_.[[Result]] with a new pass-through promise.
</emu-alg>

<h4 id="registry-entry-prototype-provide">RegistryEntry.prototype.resolve(stage, result)</h4>

The following steps are taken:

<emu-alg>
1. Let _entry_ be *this* value.
1. If Type(_entry_) is not Object, throw a new *TypeError*.
1. If _stage_ is not "fetch", "translate", "instantiate", "satisfy", "link" or "ready", return a promise rejected with a new *RangeError* exception.
1. Let _p0_ be the result of transforming _result_ with a new pass-through promise.
1. Let _p1_ be the result of transforming _p0_ with a fulfillment handler that, when called with argument _value_, runs the following steps:
  1. Let _stageEntry_ be GetStage(_entry_, _stage_).
  1. If _stageEntry_ is *undefined*, throw a new *TypeError*.
  1. If _stageEntry_.[[Result]] is *undefined*, then
    1. Set _stageEntry_.[[Result]] to a promise resolved with _value_.
  1. Else
    1. Fulfill _stageEntry_.[[Result]] with _value_.
  1. UpgradeToStage(_entry_, _stage_).
  1. Return _value_.
1. Return _p0_.
</emu-alg>

<h4 id="registry-entry-prototype-reject">RegistryEntry.prototype.reject(stage, error)</h4>

The following steps are taken:

<emu-alg>
1. Let _entry_ be *this* value.
1. If Type(_entry_) is not Object, throw a new *TypeError*.
1. If _stage_ is not "fetch", "translate", "instantiate", "satisfy", "link" or "ready", return a promise rejected with a new *RangeError* exception.
1. Let _p0_ be the result of transforming _error_ with a new pass-through promise.
1. Let _p1_ be the result of transforming _p0_ with a fulfillment handler that, when called with argument _value_, runs the following steps:
  1. Let _stageEntry_ be GetStage(_entry_, _stage_).
  1. If _stageEntry_ is *undefined*, throw a new *TypeError*.
  1. If _stageEntry_.[[Result]] is *undefined*, then
    1. Set _stageEntry_.[[Result]] to a promise rejected with _value_.
  1. Else
    1. Reject _stageEntry_.[[Result]] with _value_.
  1. UpgradeToStage(_entry_, _stage_).
  1. Return _value_.
1. Return _p0_.
</emu-alg>

<h3 id="registry-entry-internal-slots">Properties of Registry Entry Instances</h3>

RegistryEntry instances are ordinary objects that inherit properties from the %RegistryEntryPrototype%.

RegistryEntry instances are initially created with the internal slots described in the following table:

<table>
  <thead>
    <tr>
      <th>Internal Slot</th>
      <th>Value Type (<em>non-normative</em>)</th>
      <th>Description (<em>non-normative</em>)</th>
    </tr>
  </thead>
  <tr>
    <td>\[[Loader]]</td>
    <td>An object</td>
    <td>The loader this registry entry belongs to.</td>
  </tr>
  <tr>
    <td>\[[Pipeline]]</td>
    <td>A List</td>
    <td>A list whose elements are stage records.</td>
  </tr>
  <tr>
    <td>\[[Metadata]]</td>
    <td>Object or <code>undefined</code></td>
    <td>The metadata object passed through the pipeline.</td>
  </tr>
  <tr>
    <td>\[[Dependencies]]</td>
    <td>List of pairs of String and (<a href="#registry-entry">registry entry</a> or <code>undefined</code>), or <code>undefined</code>.</td>
    <td>Table mapping unresolved names to their resolved modules.</td>
  </tr>
  <tr>
    <td>\[[Module]]</td>
    <td>Module Record or Function object or <code>undefined</code></td>
    <td>The Module Record if the entry is ready, or a thunk if the entry is delayed; otherwise <code>undefined</code>.</td>
  </tr>
  <tr>
    <td>\[[Error]]</td>
    <td>Any or <b>nothing</b></td>
    <td>An error that was encountered during one of the phases of the loading pipeline; <b>nothing</b> if no error has been encountered.</td>
  </tr>
</table>

<h2 id="pipeline-semantics">Loading Semantics</h2>

<h3 id="auxiliary-operations">Auxiliary Operations</h3>

<h4 id="ensure-registered" aoid="EnsureRegistered">EnsureRegistered(loader, key)</h4>

<emu-alg>
1. Assert: _loader_ has a [[Registry]] internal slot.
1. Let _registry_ be _loader_.[[Registry]].
1. Let _pair_ be the entry in _registry_.[[Entries]] such that _pair_.[[Key]] is equal to _key_.
1. If _pair_ exists, then:
  1. Let _entry_ be _pair_.[[Value]].
1. Else:
  1. Let _entry_ be a new RegistryEntry(_loader_).
1. Return _entry_.
</emu-alg>

<h4 id="resolve" aoid="Resolve">Resolve(loader, name, referrer)</h4>

<emu-alg>
1. Let _hook_ be GetMethod(_loader_, @@resolve).
1. Return the result of promise-calling _hook_(_name_, _referrer_).
</emu-alg>

<h4 id="extract-dependencies" aoid="ExtractDependencies">ExtractDependencies(entry, optionalInstance, source)</h4>

<emu-alg>
1. Let _instance_ be Instantiation(_entry_.[[Loader]], _optionalInstance_, _source_).
1. ReturnIfAbrupt(_instance_).
1. Let _deps_ be a new empty List.
1. If _instance_ is a Module Record, then:
  1. Assert: _instance_ is a Source Text Module Record.
  1. Set _instance_.[[RegistryEntry]] to _entry_.
  1. For each _dep_ in _instance_.[[RequestedModules]], do:
    1. Append the record { [[Key]]: _dep_, [[Value]]: *undefined* } to _deps_.
1. Set _entry_.[[Dependencies]] to _deps_.
1. Set _entry_.[[Module]] to _instance_.
</emu-alg>

<h4 id="instantiation" aoid="Instantiation">Instantiation(loader, result, source)</h4>

<emu-alg>
1. If _result_ is *undefined*, then return ParseModule(_source_).
1. If IsCallable(_result_) is *false* then throw a new *TypeError*.
1. Set _result_.[[Realm]] to _loader_.[[Realm]].
1. Return _result_.
</emu-alg>

<h3 id="loading-operations">Loading Operations</h3>

<h4 id="request-fetch" aoid="RequestFetch">RequestFetch(entry)</h4>

<emu-alg>
1. Let _fetchStageEntry_ be GetStage(_entry_, "fetch").
1. If _fetchStageEntry_ is *undefined*, return a promise resolved with *undefined*.
1. Let _hook_ be GetMethod(_entry_.[[Loader]], @@fetch).
1. // TODO: metadata object
1. Let _p0_ be the result of promise-calling _hook_(_entry_).
1. Let _p1_ be the result of transforming _p0_ with a new pass-through promise.
1. Let _p2_ be the result of transforming _p1_ with a fulfillment handler that, when called with argument _payload_, runs the following steps:
  1. UpgradeToStage(_entry_, "translate").
  1. Return _payload_.
1. Set _fetchStageEntry_.[[Result]] to _p1_.
1. Return _p1_.
</emu-alg>

<h4 id="request-translate" aoid="RequestTranslate">RequestTranslate(entry)</h4>

<emu-alg>
1. Let _translateStageEntry_ be GetStage(_entry_, "translate").
1. If _translateStageEntry_ is *undefined*, return a promise resolved with *undefined*.
1. Let _hook_ be GetMethod(_entry_.[[Loader]], @@translate).
1. Let _p_ be the result of transforming RequestFetch(_entry_) with a fulfillment handler that, when called with argument _payload_, runs the following steps:
  1. Let _p0_ be the result of promise-calling _hook_(_entry_, _payload_).
  1. Let _p1_ be the result of transforming _p0_ with a new pass-through promise.
  1. Let _p2_ be the result of transforming _p1_ with a fulfillment handler that, when called with argument _source_, runs the following steps:
    1. UpgradeToStage(_entry_, "instantiate").
    1. Return _source_.
  1. Return _p1_.
1. Set _translateStageEntry_.[[Result]] to _p_.
1. Return _p_.
</emu-alg>

<h4 id="request-instantiate" aoid="RequestInstantiate">RequestInstantiate(entry)</h4>

<emu-alg>
1. Let _instantiateStageEntry_ be GetStage(_entry_, "instantiate").
1. If _instantiateStageEntry_ is *undefined*, return a promise resolved with *undefined*.
1. Let _hook_ be GetMethod(_entry_.[[Loader]], @@instantiate).
1. Let _p_ be the result of transforming RequestTranslate(_entry_) with a fulfillment handler that, when called with argument _source_, runs the following steps:
  1. Let _p0_ be the result of promise-calling _hook_(_entry_, _source_).
  1. Let _p1_ be the result of transforming _p0_ with a new pass-through promise.
  1. Let _p2_ be the result of transforming _p1_ with a fulfillment handler that, when called with argument _optionalInstance_, runs the following steps:
    1. Let _status_ be ExtractDependencies(_entry_, _optionalInstance_, _source_).
    1. ReturnIfAbrupt(_status_).
    1. UpgradeToStage(_entry_, "satisfy").
    1. Return _entry_.
  1. Return _p1_.
1. Set _instantiateStageEntry_.[[Result]] to _p_.
1. Return _p_.
</emu-alg>

<h4 id="request-satisfy" aoid="RequestSatisfy">RequestSatisfy(entry)</h4>

<emu-alg>
1. Let _satisfyStageEntry_ be GetStage(_entry_.[[Loader]], "satisfy").
1. If _satisfyStageEntry_ is *undefined*, return a promise resolved with *undefined*.
1. If _satisfyStageEntry_.[[Result]] is not *undefined*, return _satisfyStageEntry_.[[Result]].
1. Let _p_ be the result of transforming RequestInstantiate(_entry_) with a fulfillment handler that, when called with argument _entry_, runs the following steps:
  1. Let _depLoads_ be a new empty List.
  1. For each _pair_ in _entry_.[[Dependencies]], do:
    1. Let _p_ be the result of transforming Resolve(_loader_, _pair_.[[Key]], _key_) with a fulfillment handler that, when called with value _depKey_, runs the following steps:
      1. Let _depEntry_ be EnsureRegistered(_entry_.[[Loader]], _depKey_).
      1. Let _currentStageEntry_ be GetCurrentStage(_entry_).
      1. If _currentStageEntry_.[[Stage]] is "ready", then:
        1. Let _dep_ be _depEntry_.[[Module]].
        1. Set _pair_.[[Value]] to _dep_.
        1. Return _dep_.
      1. Return the result of transforming RequestSatisfy(_depEntry_.[[Loader]], _depKey_) with a fulfillment handler that, when called with value _depEntry_, runs the following steps:
        1. Let _dep_ be _depEntry_.[[Module]].
        1. Set _pair_.[[Value]] to _dep_.
        1. Return _dep_.
    1. Append _p_ to _depLoads_.
  1. Let _p_ be the result of waiting for all _depLoads_.
  1. Return the result of transforming _p_ with a fulfillment handler that, when called, runs the following steps:
    1. UpgradeToStage(_entry_, "link").
    1. Return _entry_.
1. Set _satisfyStageEntry_.[[Result]] to _p_.
1. Return _p_.
</emu-alg>

<h4 id="request-link" aoid="RequestLink">RequestLink(entry)</h4>

<emu-alg>
1. Let _linkStageEntry_ be GetStage(_entry_, "link").
1. If _linkStageEntry_ is *undefined*, return a promise resolved with *undefined*.
1. Return the result of transforming RequestSatisfy(_entry_) with a fulfillment handler that, when called with argument _entry_, runs the following steps:
  1. Assert: _entry_'s whole dependency graph is in "link" or "ready" stage.
  1. Let _status_ be Link(_entry_).
  1. ReturnIfAbrupt(_status_).
  1. Assert: _entry_'s whole dependency graph is in "ready" stage.
  1. Return _entry_.
</emu-alg>

<h4 id="request-ready" aoid="RequestReady">RequestReady(entry)</h4>

<emu-alg>
1. Let _currentStageEntry_ be GetCurrentStage(_entry_).
1. If _currentStageEntry_.[[Stage]] is equal "ready", return _currentStageEntry_.[[Result]].
1. Return the result of transforming RequestLink(_entry_) with a fulfillment handler that, when called with argument _entry_, runs the following steps:
  1. Let _module_ be _entry_.[[Module]].
  1. Let _status_ be the result of calling the ModuleEvaluation abstract operation of _module_ with no arguments.
  1. ReturnIfAbrupt(_status_).
  1. Return _module_.
</emu-alg>


<h2 id="linking-semantics">Linking Semantics</h2>

<h3 id="resolving-dependencies">Resolving Dependencies</h3>

<h4 id="host-resolve-imported-module" aoid="HostResolveImportedModule">HostResolveImportedModule(module, requestName)</h4>

The modules spec should only invoke this operation from methods of Source Text Module Records, and this spec does not invoke the operation at all.

<emu-alg>
1. Assert: _module_ is a Source Text Module Record.
1. Let _entry_ be _module_.[[RegistryEntry]].
1. Let _currentStageEntry_ be GetCurrentStage(_entry_).
1. Assert: _currentStageEntry_.[[Stage]] is in "link" or "ready" stage.
1. Let _pair_ be the pair in _entry_.[[Dependencies]] such that _pair_.[[Key]] is equal to _requestName_.
1. Assert: _pair_ is defined.
1. Let _dep_ be _pair_.[[Value]].
1. Let _depStageEntry_ be GetCurrentStage(_dep_).
1. Assert: _depStageEntry_.[[Stage]] is equal "link" or "ready" stage.
1. Return _dep_.[[Module]].
</emu-alg>

<h3 id="linking">Linking</h3>

<h4 id="link" aoid="Link">Link(root)</h4>

<emu-alg>
1. Assert: _root_ is an initialized RegistryEntry instance.
1. Let _deps_ be DependencyGraph(_root_).
1. For each _dep_ in _deps_, do:
  1. Let _depStageEntry_ be GetCurrentStage(_dep_).
  1. If _depStageEntry_.[[Stage]] is "link" and _dep_.[[Module]] is a Function object, then:
    1. Let _f_ be _dep_.[[Module]].
    1. Let _m_ be _f_().
    1. ReturnIfAbrupt(_m_).
    1. Set _dep_.[[Module]] to _m_.
    1. UpgradeToStage(_dep_, "ready").
1. Assert: the following sequence is guaranteed not to run any user code.
1. For each _dep_ in _deps_, do:
  1. Let _depStageEntry_ be GetCurrentStage(_dep_).
  1. If _depStageEntry_.[[Stage]] is "link", then:
    1. Let _module_ be _dep_.[[Module]].
    1. Assert: _module_ is a Module Record.
    1. Let _status_ be the result of calling the ModuleDeclarationInstantiation abstract operation of _module_ with no arguments.
    1. ReturnIfAbrupt(_status_).
    1. UpgradeToStage(_dep_, "ready").
1. Return *undefined*.
</emu-alg>

<h4 id="dependency-graph" aoid="DependencyGraph">DependencyGraph(root)</h4>

<emu-alg>
1. Let _result_ be a new empty List.
1. Call ComputeDependencyGraph(_root_, _result_).
1. Return _result_.
</emu-alg>

<h4 id="compute-dependency-graph" aoid="ComputeDependencyGraph">ComputeDependencyGraph(entry, result)</h4>

<emu-alg>
1. If _entry_ is already in _result_, then return *undefined*.
1. Append _entry_ to _result_.
1. For each _pair_ in _entry_.[[Dependencies]], do:
  1. Assert: _pair_.[[Value]] is defined.
  1. Call ComputeDependencyGraph(_pair_.[[Value]], _result_).
1. Return *undefined*.
</emu-alg>

<h2 id="module-objects">Module Objects</h2>

<h3 id="reflective-module-record">Reflective Module Records</h3>

A <dfn>reflective module record</dfn> is a kind of module record. It extends

<table>
  <thead>
    <tr>
      <th>Internal Slot</th>
      <th>Value Type (<em>non-normative</em>)</th>
      <th>Description (<em>non-normative</em>)</th>
    </tr>
  </thead>
  <tr>
    <td>\[[LocalExports]]</td>
    <td>A List of Strings</td>
    <td>The set of exported names stored in this module's environment.</td>
  </tr>
  <tr>
    <td>\[[IndirectExports]]</td>
    <td>A List of pairs of String and {\[[module]]: Module Record, \[[bindingName]]: String}.</td>
    <td>The set of re-exported bindings. This ensures that ResolveExport can fully resolve re-exports.</td>
  </tr>
  <tr>
    <td>\[[Evaluate]]</td>
    <td>A function object or <code>undefined</code></td>
    <td>A thunk to call when the the module is evaluated, or <code>undefined</code> if the module is already evaluated.</td>
  </tr>
</table>

-<h3 id="module-abstract-operations">Abstract Operations for Module Objects</h3>

<h4 id="parse-exports-descriptors" aoid="ParseExportsDescriptors">ParseExportsDescriptors(obj)</h4>

<b>TODO:</b> parse as in <a href="https://gist.github.com/dherman/fbf3077a2781df74b6d8">these examples</a>
<ul>
  <li>uninitialized, mutable: <code>{ }</code>
  <li>uninitialized, immutable: <code>{ const: true }</code>
  <li>initialized, mutable: <code>{ value: 42 }</code>
  <li>initialized, immutable: <code>{ value: 42, const: true }</code>
  <li>re-export (immutable): <code>{ module: m, import: "foo" }</code>
</ul>

<emu-alg>
1. // TODO: spec me
</emu-alg>

<h4 id="create-module-mutator" aoid="CreateModuleMutator">CreateModuleMutator(module)</h4>

<emu-alg>
1. // TODO: spec me
</emu-alg>


<h4 id="get-export-names" aoid="GetExportNames">GetExportNames(exportStarStack)</h4>

The following steps are taken:

<emu-alg>
1. Let _module_ be this Reflective Module Record.
1. Let _exports_ be a new empty List.
1. For each _name_ in _module_.[[LocalExports]], do:
  1. Append _name_ to _exports_.
1. For each _pair_ in _module_.[[IndirectExports]], do:
  1. Append _pair_.[[Key]] to _exports_.
1. Return _exports_.
</emu-alg>

<h4 id="resolve-export" aoid="ResolveExport">ResolveExport(exportName, resolveStack, exportStarStack)</h4>

<emu-alg>
1. Let _module_ be this Reflective Module Record.
1. If _resolveStack_ contains a record _r_ such that _r_.[[module]] is equal to _module_ and _r_.[[exportName]] is equal to _exportName_, then
  1. Assert: this is a circular import request.
  1. Throw a *SyntaxError* exception.
1. Append the record {[[module]]: _module_, [[exportName]]: _exportName_} to _resolveStack_.
1. Let _exports_ be _module_.[[LocalExports]].
1. Let _pair_ be the pair in _exports_ such that _pair_.[[Key]] is equal to _exportName_.
1. If _pair_ is defined, then:
  1. Return the Record { [[module]]: _module_, [[bindingName]]: _exportName_ }.
1. Let _exports_ be _module_.[[IndirectExports]].
1. Let _pair_ be the pair in _exports_ such that _pair_.[[Key]] is equal to _exportName_.
1. If _pair_ is defined, then return _pair_.[[Value]].
1. Return *null*.
</emu-alg>

<h4 id="module-declaration-instantiation" aoid="ModuleDeclarationInstantiation">ModuleDeclarationInstantiation()</h4>

Reflective modules are always already instantiated.

<emu-alg>
1. Return *undefined*.
</emu-alg>

<h4 id="module-evaluation" aoid="ModuleEvaluation">ModuleEvaluation()</h4>

<emu-alg>
1. Let _module_ be this Reflective Module Record.
1. Let _evaluate_ be _module_.[[Evaluate]].
1. Set _module_.[[Evaluate]] to *undefined*.
1. Return _evaluate_().
</emu-alg>

<h3 id="module-constructor">The Reflect.Module Constructor</h3>

The Module constructor is the initial value of the Module property of the the Reflect object. When called as a constructor it creates and initializes a new Module object. Reflect.Module is not intended to be called as a function and will throw an exception when called in that manner.

The Reflect.Module constructor is designed to be subclassable. It may be used as the value in an extends clause of a class definition. Subclass constructors that intend to inherit the specified Module behaviour must include a super call to the Reflect.Module constructor to create and initialize the subclass instance with the internal stage necessary to integrated with loaders.

<h4 id="new-reflect-module">Reflect.Module(descriptors[, executor[, evaluate]])</h4>

When Reflect.Module is called with arguments <i>descriptors</i>, <i>executor</i>, and <i>evaluate</i>, the following steps are taken:

<emu-alg>
1. Let _realm_ be the current Realm.
1. Let _env_ be NewModuleEnvironment(_realm_.[[globalEnv]]).
1. Let _exportDescriptors_ be ParseExportsDescriptors(_descriptors_). // TODO: interleave the subsequent loop with parsing?
1. Let _localExports_ be a new empty List.
1. Let _indirectExports_ be a new empty List.
1. Let _exportNames_ be a new empty List.
1. Let _envRec_ be _env_'s environment record.
1. For each _desc_ in _exportDescriptors_, do:
  1. Let _exportName_ be _desc_.[[Name]].
  1. Append _exportName_ to _exportNames_.
  1. If _desc_ is an Indirect Export Descriptor, then:
    1. Let _otherMod_ be _desc_.[[Module]].
    1. Let _resolution_ be _otherMod_.ResolveExport(_desc_.[[Import]], « »).
    1. ReturnIfAbrupt(_resolution_).
    1. If _resolution_ is *null*, then throw a *SyntaxError* exception.
    1. Append the record {[[Key]]: _exportName_, [[Value]]: _resolution_} to _indirectExports_.
  1. Else:
    1. Append _exportName_ to _localExports_.
    1. If _desc_ is an Immutable Export Descriptor, then:
      1. Let _status_ be _envRec_.CreateImmutableBinding(_exportName_, *true*).
      1. Assert: _status_ is not an abrupt completion.
    1. Else:
      1. Assert: _desc_ is a Mutable Export Descriptor.
      1. Let _status_ be _envRec_.CreateMutableBinding(_exportName_, *false*).
      1. Assert: _status_ is not an abrupt completion.
    1. If _desc_.[[Initialized]] is *true*, then:
      1. Call _envRec_.InitializeBinding(_exportName_, _desc_.[[Value]]).
1. If _evaluate_ is *undefined*, then let _evaluated_ be *true*. Otherwise let _evaluated_ be *false*.
1. Let _mod_ be a new Reflective Module Record {[[Realm]]: _realm_, [[Environment]]: _env_, [[Namespace]]: *undefined*, [[Evaluated]]: _evaluated_, [[LocalExports]]: _localExports_, [[IndirectExports]]: _indirectExports_, [[Evaluate]]: _evaluate_}.
1. Let _ns_ be ModuleNamespaceCreate(_mod_, _realm_, _exportNames_).
1. Set _mod_.[[Namespace]] to _ns_.
1. If _executor_ is not *undefined*, then
  1. Let _mutator_ be CreateModuleMutator(_mod_).
  1. Let _status_ be _executor_(_mutator_, _ns_).
  1. ReturnIfAbrupt(_status_).
1. Return _ns_.
</emu-alg>

<h3 id="properties-of-the-module-constructor">Properties of the Reflect.Module Constructor</h3>

The value of the \[[Prototype]] internal slot of the Reflect.Module constructor is the intrinsic object %FunctionPrototype%.

Besides the internal slots and the length property (whose value is 0), the Reflect.Loader constructor has the following properties:

<h4 id="Reflect.Module.evaluate">Reflect.Module.evaluate(m)</h4>

<b>TODO:</b> way to force evaluation of a module namespace exotic object (<code>Reflect.Module.evaluate(m)</code>? <code>m[Reflect.Module.evaluate]()</code>?)

<h4 id="Reflect.Module.prototype">Reflect.Module.prototype</h4>

The value of Reflect.Module.prototype is an ordinary object with a null \[[Prototype]].

This property has the attributes { \[[Writable]]: false, \[[Enumerable]]: false, \[[Configurable]]: false }.

<h3 id="reflect-module-internal-slots">Properties of Module Instances</h3>

Reflect.Module instances are module namespace exotic objects.

<h2 id="local">Local Loading</h2>

<b>TODO:</b>

<ul>
<li>syntax for accessing module local information: <code>import local from this;</code>
<li>dynamic import: <code>local.import()</code>
<li>extending the hooks to handle <code>this</code>
<li>debugging info
<li>room for host environment-specific data
</ul>


<h2 id="browser">Browser Loader</h2>

Every host environment must implement a default loader object as the initial value of the loader property of the System object.

<h3 id="system-loader-instance">System.loader Object</h3>

The Default Browser Loader Object is an %BrowserLoader% instance, whose internal slots are set as if it had been constructed by the expression Construct(%BrowserLoader%).

<h2 id="browser-loader">BrowserLoader Objects</h2>

<h3 id="browser-loader-constructor">The BrowserLoader Constructor</h3>

The BrowserLoader constructor is the %BrowserLoader% intrinsic object. When called as a constructor it creates and initializes a new %BrowserLoader% object. %BrowserLoader% is not intended to be called as a function and will throw an exception when called in that manner.

<h3 id="properties-of-the-browser-loader-constructor">Properties of the BrowserLoader Constructor</h3>

The value of the \[[Prototype]] internal slot of the BrowserLoader constructor is the intrinsic object %FunctionPrototype%.

Besides the internal slots and the length property (whose value is 0), the BrowserLoader constructor has the following properties:

<h4 id="browser-loader-prototype">BrowserLoader.prototype</h4>

The value of BrowserLoader.prototype is %BrowserLoaderPrototype%.

This property has the attributes { \[[Writable]]: false, \[[Enumerable]]: false, \[[Configurable]]: false }.

<h3 id="properties-of-the-browser-loader-prototype">Properties of the BrowserLoader Prototype</h3>

<h4 id="browser-loader-prototype-@@resolve">BrowserLoader.prototype[ @@resolve ](name, referrer)</h4>

When the @@resolve method is called, the following steps are taken:

<b>TODO:</b> name resolution policy
<ul>
  <li>relative and site-relative URLs: <code>"./utils.js"</code>, <code>"/scripts/utils.js"</code>
  <li>JS standard modules: <code>"std/math"</code>, <code>"std/json"</code>, <code>"std/reflect"</code>
  <li>Web standard modules: <code>"web/worker"</code>, <code>"web/audio"</code>
  <li>absolute URLs: <code>"https://cdn.example.com/jquery/v/2.0"</code>
</ul>

The value of the name property of this function is "[Reflect.Loader.resolve]".

<h4 id="browser-loader-prototype-@@fetch">BrowserLoader.prototype[ @@fetch ](entry)</h4>

When the @@fetch method is called, the following steps are taken:

<b>TODO:</b>
<ul>
  <li>reference fetch standard
  <li>cross-origin produces an opaque object as in ServiceWorker
  <li>CORS, CSP
  <li>other kinds of web assets
</ul>

The value of the name property of this function is "[Reflect.Loader.fetch]".

<h4 id="browser-loader-prototype-@@translate">BrowserLoader.prototype[ @@translate ](entry, payload)</h4>

When the @@translate method is called, the following steps are taken:

<b>TODO:</b> no-op.

The value of the name property of this function is "[Reflect.Loader.translate]".

<h4 id="browser-loader-prototype-@@instantiate">BrowserLoader.prototype[ @@instantiate ](entry, source)</h4>

When the @@instantiate method is called, the following steps are taken:

<b>TODO:</b>
<ul>
  <li>basically a no-op.
  <li>but also needs to re-absorb opaque responses.
</ul>

The value of the name property of this function is "[Reflect.Loader.instantiate]".

<h2 id="annexes" class="no-num">Annexes</h2>

<h3 id="list-of-well-known-intrinsic-objects">List of Well-Known Intrinsic Objects</h3>

The intrinsics are listed in table below:

<table>
  <thead>
    <tr>
      <th>Intrinsic Name</th>
      <th>Description (<em>non-normative</em>)</th>
    </tr>
  </thead>
  <tr>
    <td>%BrowserLoader%</td>
    <td>The browser loader constructor (<a href="#browser-loader-constructor">10.1</a>)</td>
  </tr>
  <tr>
    <td>%BrowserLoaderPrototype%</td>
    <td>The initial value of the *prototype* data property of %BrowserLoader% (<a href="#browser-loader-prototype">10.2.1</a>)</td>
  </tr>
  <tr>
    <td>%Registry%</td>
    <td>The registry constructor (<a href="#registry-constructor">4.1</a>)</td>
  </tr>
  <tr>
    <td>%RegistryPrototype%</td>
    <td>The initial value of the *prototype* data property of %Registry% (<a href="#registry-prototype">4.3.1</a>)</td>
  </tr>
</table>
